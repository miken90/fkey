// FKey Frontend JavaScript
// Communicates with Go backend via Wails v3 runtime

// Current settings state
let currentSettings = {};
let isLoading = true;

// Binding IDs (generated by wails3 generate bindings)
const BindingIDs = {
    GetSettings: 3726452464,
    SaveSettings: 1235119979,
    Toggle: 4113297479,
    SetInputMethod: 526728894,
    GetVersion: 3451983167,
    GetEnabled: 4139715286,
    SetEnabled: 1538332202,
};

// Wait for Wails runtime to be ready
function waitForWails() {
    return new Promise((resolve) => {
        // Check if wails global is available (from runtime.js)
        const check = () => {
            if (typeof wails !== 'undefined' && wails.Call && wails.Call.ByID) {
                resolve();
                return true;
            }
            return false;
        };
        
        if (check()) return;
        
        // Poll for runtime
        const checkInterval = setInterval(() => {
            if (check()) {
                clearInterval(checkInterval);
            }
        }, 50);
        
        // Timeout after 5 seconds
        setTimeout(() => {
            clearInterval(checkInterval);
            resolve(); // Continue anyway, will show error
        }, 5000);
    });
}

// Wails v3 Call wrapper using ByID
const App = {
    GetSettings: async () => {
        try {
            return await wails.Call.ByID(BindingIDs.GetSettings);
        } catch (e) {
            console.error('GetSettings error:', e);
            throw e;
        }
    },
    SaveSettings: async (settings) => {
        return await wails.Call.ByID(BindingIDs.SaveSettings, settings);
    },
    Toggle: async () => {
        return await wails.Call.ByID(BindingIDs.Toggle);
    },
    SetInputMethod: async (method) => {
        return await wails.Call.ByID(BindingIDs.SetInputMethod, method);
    },
    GetVersion: async () => {
        return await wails.Call.ByID(BindingIDs.GetVersion);
    },
};

document.addEventListener('DOMContentLoaded', async () => {
    console.log('FKey Settings UI initializing...');
    
    // Wait for Wails runtime
    await waitForWails();
    
    if (typeof wails === 'undefined' || !wails.Call) {
        showError('Không thể kết nối với ứng dụng. Vui lòng khởi động lại.');
        return;
    }
    
    console.log('Wails runtime ready');
    
    try {
        // Load settings from backend
        currentSettings = await App.GetSettings();
        console.log('Settings loaded:', currentSettings);
        applySettingsToUI(currentSettings);
        
        // Load version
        const version = await App.GetVersion();
        document.getElementById('versionText').textContent = `FKey v${version}`;
        
        isLoading = false;
        document.body.classList.remove('loading');
    } catch (err) {
        console.error('Failed to load settings:', err);
        showError('Không thể tải cài đặt: ' + err.message);
    }
    
    // Set up event listeners
    setupEventListeners();
});

function showError(msg) {
    const container = document.querySelector('.container');
    const existing = container.querySelector('.error-msg');
    if (existing) existing.remove();
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-msg';
    errorDiv.textContent = msg;
    container.insertBefore(errorDiv, container.firstChild.nextSibling);
}

function applySettingsToUI(settings) {
    // Status indicator
    updateStatusIndicator(settings.enabled);
    
    // Input method
    const methodRadios = document.querySelectorAll('input[name="inputMethod"]');
    methodRadios.forEach(radio => {
        radio.checked = parseInt(radio.value) === settings.inputMethod;
    });
    
    // Tone style
    const toneRadios = document.querySelectorAll('input[name="toneStyle"]');
    toneRadios.forEach(radio => {
        radio.checked = (radio.value === 'modern') === settings.modernTone;
    });
    
    // Hotkey display
    updateHotkeyDisplay(settings.toggleHotkey);
    
    // Advanced settings
    const checkboxes = {
        'skipW': settings.skipWShortcut,
        'escRestore': settings.escRestore !== false,
        'freeTone': settings.freeTone,
        'englishRestore': settings.englishAutoRestore,
        'autoCapitalize': settings.autoCapitalize !== false,
        'autoStart': settings.autoStart
    };
    
    for (const [id, value] of Object.entries(checkboxes)) {
        const el = document.getElementById(id);
        if (el) el.checked = value || false;
    }
}

function updateStatusIndicator(enabled) {
    const indicator = document.getElementById('statusIndicator');
    const dot = indicator.querySelector('.status-dot');
    const text = indicator.querySelector('.status-text');
    
    if (enabled) {
        dot.classList.remove('disabled');
        text.textContent = 'Tiếng Việt: Đang bật';
    } else {
        dot.classList.add('disabled');
        text.textContent = 'Tiếng Việt: Đang tắt';
    }
}

function updateHotkeyDisplay(hotkeyStr) {
    const btn = document.getElementById('hotkeyBtn');
    if (!hotkeyStr) {
        btn.textContent = 'Ctrl+Space';
        return;
    }
    
    const parts = hotkeyStr.split(',');
    if (parts.length < 2) {
        btn.textContent = 'Ctrl+Space';
        return;
    }
    
    const keyCode = parseInt(parts[0]);
    const modifiers = parseInt(parts[1]);
    
    let display = [];
    if (modifiers & 1) display.push('Ctrl');
    if (modifiers & 2) display.push('Alt');
    if (modifiers & 4) display.push('Shift');
    
    display.push(getKeyName(keyCode));
    btn.textContent = display.join('+');
}

function getKeyName(keyCode) {
    const keyMap = {
        0x20: 'Space', 0x08: 'Backspace', 0x09: 'Tab',
        0x0D: 'Enter', 0x1B: 'Escape',
        0x70: 'F1', 0x71: 'F2', 0x72: 'F3', 0x73: 'F4',
        0x74: 'F5', 0x75: 'F6', 0x76: 'F7', 0x77: 'F8',
        0x78: 'F9', 0x79: 'F10', 0x7A: 'F11', 0x7B: 'F12',
    };
    
    if (keyMap[keyCode]) return keyMap[keyCode];
    if (keyCode >= 0x41 && keyCode <= 0x5A) return String.fromCharCode(keyCode);
    if (keyCode >= 0x30 && keyCode <= 0x39) return String.fromCharCode(keyCode);
    
    return `Key${keyCode}`;
}

function setupEventListeners() {
    // Status toggle (click on status section)
    document.querySelector('.status-section').addEventListener('click', async () => {
        if (isLoading) return;
        try {
            const newState = await App.Toggle();
            currentSettings.enabled = newState;
            updateStatusIndicator(newState);
        } catch (err) {
            console.error('Failed to toggle:', err);
        }
    });
    
    // Input method change
    document.querySelectorAll('input[name="inputMethod"]').forEach(radio => {
        radio.addEventListener('change', async (e) => {
            if (isLoading) return;
            const method = parseInt(e.target.value);
            try {
                await App.SetInputMethod(method);
                currentSettings.inputMethod = method;
                console.log('Input method:', method === 0 ? 'Telex' : 'VNI');
            } catch (err) {
                console.error('Failed to set input method:', err);
            }
        });
    });
    
    // Tone style change
    document.querySelectorAll('input[name="toneStyle"]').forEach(radio => {
        radio.addEventListener('change', async (e) => {
            if (isLoading) return;
            currentSettings.modernTone = e.target.value === 'modern';
            await saveSettings();
        });
    });
    
    // Advanced settings checkboxes
    const checkboxMapping = {
        'skipW': 'skipWShortcut',
        'escRestore': 'escRestore',
        'freeTone': 'freeTone',
        'englishRestore': 'englishAutoRestore',
        'autoCapitalize': 'autoCapitalize',
        'autoStart': 'autoStart',
    };
    
    Object.entries(checkboxMapping).forEach(([elemId, settingKey]) => {
        const el = document.getElementById(elemId);
        if (el) {
            el.addEventListener('change', async (e) => {
                if (isLoading) return;
                currentSettings[settingKey] = e.target.checked;
                await saveSettings();
            });
        }
    });
    
    // Hotkey button - recording mode
    const hotkeyBtn = document.getElementById('hotkeyBtn');
    let isRecording = false;
    
    hotkeyBtn.addEventListener('click', () => {
        if (isRecording) return;
        isRecording = true;
        hotkeyBtn.textContent = 'Nhấn phím...';
        hotkeyBtn.classList.add('recording');
        console.log('Hotkey recording started');
        
        const handler = async (e) => {
            console.log('Key pressed:', e.key, 'keyCode:', e.keyCode, 'modifiers:', e.ctrlKey, e.altKey, e.shiftKey);
            e.preventDefault();
            e.stopPropagation();
            
            // Ignore modifier-only presses
            if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
                return;
            }
            
            const keyCode = e.keyCode;
            let modifiers = 0;
            if (e.ctrlKey) modifiers |= 1;
            if (e.altKey) modifiers |= 2;
            if (e.shiftKey) modifiers |= 4;
            
            // Require at least one modifier
            if (modifiers === 0) {
                hotkeyBtn.textContent = 'Cần Ctrl/Alt/Shift';
                setTimeout(() => {
                    updateHotkeyDisplay(currentSettings.toggleHotkey);
                    hotkeyBtn.classList.remove('recording');
                    isRecording = false;
                }, 1200);
                document.removeEventListener('keydown', handler);
                return;
            }
            
            currentSettings.toggleHotkey = `${keyCode},${modifiers}`;
            console.log('New hotkey set:', currentSettings.toggleHotkey);
            updateHotkeyDisplay(currentSettings.toggleHotkey);
            hotkeyBtn.classList.remove('recording');
            isRecording = false;
            document.removeEventListener('keydown', handler);
            
            await saveSettings();
        };
        
        document.addEventListener('keydown', handler);
    });
    
    // Feedback link
    document.getElementById('feedbackLink')?.addEventListener('click', (e) => {
        e.preventDefault();
        if (wails.Browser && wails.Browser.OpenURL) {
            wails.Browser.OpenURL('https://github.com/miken90/gonhanh.org/issues');
        } else {
            window.open('https://github.com/miken90/gonhanh.org/issues', '_blank');
        }
    });
}

async function saveSettings() {
    try {
        await App.SaveSettings(currentSettings);
        console.log('Settings saved');
    } catch (err) {
        console.error('Failed to save settings:', err);
    }
}
