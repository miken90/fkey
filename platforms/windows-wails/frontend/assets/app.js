// FKey Frontend JavaScript
// Communicates with Go backend via Wails v3 runtime

// Current settings state
let currentSettings = {};
let currentShortcuts = [];
let isLoading = true;

// Binding IDs (generated by wails3 generate bindings)
const BindingIDs = {
    GetSettings: 3726452464,
    SaveSettings: 1235119979,
    Toggle: 4113297479,
    SetInputMethod: 526728894,
    GetVersion: 3451983167,
    GetEnabled: 4139715286,
    SetEnabled: 1538332202,
    GetShortcuts: 96855928,
    SaveShortcuts: 2491486897,
    CheckForUpdates: 152619814,
    DownloadAndInstallUpdate: 29466370,
};

// Wait for Wails runtime to be ready
function waitForWails() {
    return new Promise((resolve) => {
        // Check if wails global is available (from runtime.js)
        const check = () => {
            if (typeof wails !== 'undefined' && wails.Call && wails.Call.ByID) {
                resolve();
                return true;
            }
            return false;
        };
        
        if (check()) return;
        
        // Poll for runtime
        const checkInterval = setInterval(() => {
            if (check()) {
                clearInterval(checkInterval);
            }
        }, 50);
        
        // Timeout after 5 seconds
        setTimeout(() => {
            clearInterval(checkInterval);
            resolve(); // Continue anyway, will show error
        }, 5000);
    });
}

// Wails v3 Call wrapper using ByID
const App = {
    GetSettings: async () => {
        try {
            return await wails.Call.ByID(BindingIDs.GetSettings);
        } catch (e) {
            console.error('GetSettings error:', e);
            throw e;
        }
    },
    SaveSettings: async (settings) => {
        return await wails.Call.ByID(BindingIDs.SaveSettings, settings);
    },
    Toggle: async () => {
        return await wails.Call.ByID(BindingIDs.Toggle);
    },
    SetInputMethod: async (method) => {
        return await wails.Call.ByID(BindingIDs.SetInputMethod, method);
    },
    GetVersion: async () => {
        return await wails.Call.ByID(BindingIDs.GetVersion);
    },
    GetShortcuts: async () => {
        try {
            return await wails.Call.ByID(BindingIDs.GetShortcuts);
        } catch (e) {
            console.error('GetShortcuts error:', e);
            return [];
        }
    },
    SaveShortcuts: async (shortcuts) => {
        return await wails.Call.ByID(BindingIDs.SaveShortcuts, shortcuts);
    },
    CheckForUpdates: async (force) => {
        try {
            return await wails.Call.ByID(BindingIDs.CheckForUpdates, force);
        } catch (e) {
            console.error('CheckForUpdates error:', e);
            return null;
        }
    },
    DownloadAndInstallUpdate: async (downloadURL) => {
        return await wails.Call.ByID(BindingIDs.DownloadAndInstallUpdate, downloadURL);
    },
};

document.addEventListener('DOMContentLoaded', async () => {
    console.log('FKey Settings UI initializing...');
    
    // Wait for Wails runtime
    await waitForWails();
    
    if (typeof wails === 'undefined' || !wails.Call) {
        showError('Không thể kết nối với ứng dụng. Vui lòng khởi động lại.');
        return;
    }
    
    console.log('Wails runtime ready');
    
    try {
        // Load settings from backend
        currentSettings = await App.GetSettings();
        console.log('Settings loaded:', currentSettings);
        applySettingsToUI(currentSettings);
        
        // Load version
        const version = await App.GetVersion();
        document.getElementById('versionText').textContent = `FKey v${version}`;
        
        // Load shortcuts
        await loadShortcuts();
        
        isLoading = false;
        document.body.classList.remove('loading');
    } catch (err) {
        console.error('Failed to load settings:', err);
        showError('Không thể tải cài đặt: ' + err.message);
    }
    
    // Set up event listeners
    setupEventListeners();
    
    // Check for updates (async, non-blocking)
    checkForUpdates();
});

async function checkForUpdates() {
    try {
        const updateInfo = await App.CheckForUpdates(false);
        if (updateInfo && updateInfo.available && updateInfo.downloadURL) {
            showUpdateDialog(updateInfo);
        }
    } catch (e) {
        console.log('Update check failed:', e);
    }
}

function showUpdateDialog(updateInfo) {
    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.className = 'update-overlay';
    overlay.innerHTML = `
        <div class="update-dialog">
            <h3>Cập nhật mới</h3>
            <p>Phiên bản <strong>${updateInfo.latestVersion}</strong> đã sẵn sàng!</p>
            <p class="update-notes">${updateInfo.releaseNotes || ''}</p>
            <div class="update-buttons">
                <button class="update-btn-yes">Cập nhật ngay</button>
                <button class="update-btn-no">Để sau</button>
            </div>
            <p class="update-status" style="display:none;"></p>
        </div>
    `;
    document.body.appendChild(overlay);
    
    overlay.querySelector('.update-btn-yes').addEventListener('click', async () => {
        const status = overlay.querySelector('.update-status');
        const buttons = overlay.querySelector('.update-buttons');
        buttons.style.display = 'none';
        status.style.display = 'block';
        status.textContent = 'Đang tải xuống...';
        
        try {
            await App.DownloadAndInstallUpdate(updateInfo.downloadURL);
            status.textContent = 'Đang cài đặt, ứng dụng sẽ khởi động lại...';
            // App will be closed by the backend, batch script will restart
            setTimeout(() => {
                if (wails.Window && wails.Window.Close) {
                    wails.Window.Close();
                } else if (wails.Application && wails.Application.Quit) {
                    wails.Application.Quit();
                }
            }, 1000);
        } catch (e) {
            status.textContent = 'Lỗi: ' + e.message;
            buttons.style.display = 'flex';
        }
    });
    
    overlay.querySelector('.update-btn-no').addEventListener('click', () => {
        overlay.remove();
    });
}

function showError(msg) {
    const container = document.querySelector('.container');
    const existing = container.querySelector('.error-msg');
    if (existing) existing.remove();
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-msg';
    errorDiv.textContent = msg;
    container.insertBefore(errorDiv, container.firstChild.nextSibling);
}

function applySettingsToUI(settings) {
    // Status indicator
    updateStatusIndicator(settings.enabled);
    
    // Input method
    const methodRadios = document.querySelectorAll('input[name="inputMethod"]');
    methodRadios.forEach(radio => {
        radio.checked = parseInt(radio.value) === settings.inputMethod;
    });
    
    // Tone style
    // NOTE: Rust engine uses inverted terminology:
    // - modern_tone=true  → hoà, thuý (dấu ở nguyên âm sau - actually old style in VietNet)  
    // - modern_tone=false → hòa, thúy (dấu ở nguyên âm đầu - actually new style in VietNet)
    // UI shows: "Mới (hòa)" and "Cũ (hoà)", so we invert the mapping
    const toneRadios = document.querySelectorAll('input[name="toneStyle"]');
    toneRadios.forEach(radio => {
        radio.checked = (radio.value === 'modern') !== settings.modernTone;
    });
    
    // Hotkey display
    updateHotkeyDisplay(settings.toggleHotkey);
    
    // Advanced settings
    const checkboxes = {
        'skipW': settings.skipWShortcut,
        'escRestore': settings.escRestore !== false,
        'freeTone': settings.freeTone,
        'englishRestore': settings.englishAutoRestore,
        'autoCapitalize': settings.autoCapitalize !== false,
        'autoStart': settings.autoStart
    };
    
    for (const [id, value] of Object.entries(checkboxes)) {
        const el = document.getElementById(id);
        if (el) el.checked = value || false;
    }
}

function updateStatusIndicator(enabled) {
    const indicator = document.getElementById('statusIndicator');
    const dot = indicator.querySelector('.status-dot');
    const text = indicator.querySelector('.status-text');
    
    if (enabled) {
        dot.classList.remove('disabled');
        text.textContent = 'Tiếng Việt: Đang bật';
    } else {
        dot.classList.add('disabled');
        text.textContent = 'Tiếng Việt: Đang tắt';
    }
}

function updateHotkeyDisplay(hotkeyStr) {
    const btn = document.getElementById('hotkeyBtn');
    if (!hotkeyStr) {
        btn.textContent = 'Ctrl+Space';
        return;
    }
    
    const parts = hotkeyStr.split(',');
    if (parts.length < 2) {
        btn.textContent = 'Ctrl+Space';
        return;
    }
    
    const keyCode = parseInt(parts[0]);
    const modifiers = parseInt(parts[1]);
    
    let display = [];
    if (modifiers & 1) display.push('Ctrl');
    if (modifiers & 2) display.push('Alt');
    if (modifiers & 4) display.push('Shift');
    
    display.push(getKeyName(keyCode));
    btn.textContent = display.join('+');
}

function getKeyName(keyCode) {
    const keyMap = {
        0x20: 'Space', 0x08: 'Backspace', 0x09: 'Tab',
        0x0D: 'Enter', 0x1B: 'Escape',
        0x70: 'F1', 0x71: 'F2', 0x72: 'F3', 0x73: 'F4',
        0x74: 'F5', 0x75: 'F6', 0x76: 'F7', 0x77: 'F8',
        0x78: 'F9', 0x79: 'F10', 0x7A: 'F11', 0x7B: 'F12',
    };
    
    if (keyMap[keyCode]) return keyMap[keyCode];
    if (keyCode >= 0x41 && keyCode <= 0x5A) return String.fromCharCode(keyCode);
    if (keyCode >= 0x30 && keyCode <= 0x39) return String.fromCharCode(keyCode);
    
    return `Key${keyCode}`;
}

function setupEventListeners() {
    // Status toggle (click on status section)
    document.querySelector('.status-section').addEventListener('click', async () => {
        if (isLoading) return;
        try {
            const newState = await App.Toggle();
            currentSettings.enabled = newState;
            updateStatusIndicator(newState);
        } catch (err) {
            console.error('Failed to toggle:', err);
        }
    });
    
    // Shortcut form submit
    const shortcutForm = document.getElementById('shortcutForm');
    if (shortcutForm) {
        shortcutForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const triggerInput = document.getElementById('triggerInput');
            const replacementInput = document.getElementById('replacementInput');
            const trigger = triggerInput.value.trim();
            const replacement = replacementInput.value.trim();
            
            if (trigger && replacement) {
                await addShortcut(trigger, replacement);
                triggerInput.value = '';
                replacementInput.value = '';
                triggerInput.focus();
            }
        });
    }
    
    // Input method change
    document.querySelectorAll('input[name="inputMethod"]').forEach(radio => {
        radio.addEventListener('change', async (e) => {
            if (isLoading) return;
            const method = parseInt(e.target.value);
            try {
                await App.SetInputMethod(method);
                currentSettings.inputMethod = method;
                console.log('Input method:', method === 0 ? 'Telex' : 'VNI');
            } catch (err) {
                console.error('Failed to set input method:', err);
            }
        });
    });
    
    // Tone style change
    // NOTE: Invert the value because Rust engine uses inverted terminology
    document.querySelectorAll('input[name="toneStyle"]').forEach(radio => {
        radio.addEventListener('change', async (e) => {
            if (isLoading) return;
            currentSettings.modernTone = e.target.value !== 'modern';
            await saveSettings();
        });
    });
    
    // Advanced settings checkboxes
    const checkboxMapping = {
        'skipW': 'skipWShortcut',
        'escRestore': 'escRestore',
        'freeTone': 'freeTone',
        'englishRestore': 'englishAutoRestore',
        'autoCapitalize': 'autoCapitalize',
        'autoStart': 'autoStart',
    };
    
    Object.entries(checkboxMapping).forEach(([elemId, settingKey]) => {
        const el = document.getElementById(elemId);
        if (el) {
            el.addEventListener('change', async (e) => {
                if (isLoading) return;
                currentSettings[settingKey] = e.target.checked;
                await saveSettings();
            });
        }
    });
    
    // Hotkey button - recording mode
    const hotkeyBtn = document.getElementById('hotkeyBtn');
    let isRecording = false;
    
    hotkeyBtn.addEventListener('click', () => {
        if (isRecording) return;
        isRecording = true;
        hotkeyBtn.textContent = 'Nhấn phím...';
        hotkeyBtn.classList.add('recording');
        console.log('Hotkey recording started');
        
        const handler = async (e) => {
            console.log('Key pressed:', e.key, 'keyCode:', e.keyCode, 'modifiers:', e.ctrlKey, e.altKey, e.shiftKey);
            e.preventDefault();
            e.stopPropagation();
            
            // Ignore modifier-only presses
            if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
                return;
            }
            
            const keyCode = e.keyCode;
            let modifiers = 0;
            if (e.ctrlKey) modifiers |= 1;
            if (e.altKey) modifiers |= 2;
            if (e.shiftKey) modifiers |= 4;
            
            // Require at least one modifier
            if (modifiers === 0) {
                hotkeyBtn.textContent = 'Cần Ctrl/Alt/Shift';
                setTimeout(() => {
                    updateHotkeyDisplay(currentSettings.toggleHotkey);
                    hotkeyBtn.classList.remove('recording');
                    isRecording = false;
                }, 1200);
                document.removeEventListener('keydown', handler);
                return;
            }
            
            currentSettings.toggleHotkey = `${keyCode},${modifiers}`;
            console.log('New hotkey set:', currentSettings.toggleHotkey);
            updateHotkeyDisplay(currentSettings.toggleHotkey);
            hotkeyBtn.classList.remove('recording');
            isRecording = false;
            document.removeEventListener('keydown', handler);
            
            await saveSettings();
        };
        
        document.addEventListener('keydown', handler);
    });
    
    // Feedback link
    document.getElementById('feedbackLink')?.addEventListener('click', (e) => {
        e.preventDefault();
        if (wails.Browser && wails.Browser.OpenURL) {
            wails.Browser.OpenURL('https://github.com/miken90/fkey/issues');
        } else {
            window.open('https://github.com/miken90/fkey/issues', '_blank');
        }
    });
}

async function saveSettings() {
    try {
        await App.SaveSettings(currentSettings);
        console.log('Settings saved');
    } catch (err) {
        console.error('Failed to save settings:', err);
    }
}

// Shortcuts CRUD
async function loadShortcuts() {
    try {
        currentShortcuts = await App.GetShortcuts() || [];
        renderShortcuts();
        console.log('Shortcuts loaded:', currentShortcuts.length);
    } catch (err) {
        console.error('Failed to load shortcuts:', err);
        currentShortcuts = [];
        renderShortcuts();
    }
}

async function saveShortcuts() {
    try {
        await App.SaveShortcuts(currentShortcuts);
        console.log('Shortcuts saved');
    } catch (err) {
        console.error('Failed to save shortcuts:', err);
    }
}

function renderShortcuts() {
    const list = document.getElementById('shortcutList');
    if (!list) return;
    
    if (currentShortcuts.length === 0) {
        list.innerHTML = '<div class="shortcut-empty">Chưa có viết tắt nào</div>';
        return;
    }
    
    list.innerHTML = currentShortcuts.map((s, i) => {
        const enabled = s.enabled !== false;
        return `
        <div class="shortcut-item${enabled ? '' : ' disabled'}" data-index="${i}">
            <input type="checkbox" class="toggle-btn" ${enabled ? 'checked' : ''} title="Bật/tắt">
            <span class="trigger">${escapeHtml(s.trigger)}</span>
            <span class="arrow">→</span>
            <span class="replacement">${escapeHtml(s.replacement)}</span>
            <button class="edit-btn" title="Sửa">✎</button>
            <button class="delete-btn" title="Xóa">×</button>
        </div>
    `}).join('');
    
    list.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('change', (e) => {
            const index = parseInt(e.target.closest('.shortcut-item').dataset.index);
            toggleShortcut(index, e.target.checked);
        });
    });
    
    list.querySelectorAll('.edit-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.closest('.shortcut-item').dataset.index);
            editShortcut(index);
        });
    });
    
    list.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.closest('.shortcut-item').dataset.index);
            deleteShortcut(index);
        });
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function addShortcut(trigger, replacement) {
    if (!trigger || !replacement) return;
    
    if (editingIndex >= 0) {
        currentShortcuts[editingIndex].trigger = trigger;
        currentShortcuts[editingIndex].replacement = replacement;
    } else {
        const existing = currentShortcuts.findIndex(s => s.trigger === trigger);
        if (existing >= 0) {
            currentShortcuts[existing].replacement = replacement;
        } else {
            currentShortcuts.push({ trigger, replacement, enabled: true });
        }
    }
    
    renderShortcuts();
    resetForm();
    await saveShortcuts();
}

async function deleteShortcut(index) {
    if (index < 0 || index >= currentShortcuts.length) return;
    currentShortcuts.splice(index, 1);
    renderShortcuts();
    await saveShortcuts();
}

async function toggleShortcut(index, enabled) {
    if (index < 0 || index >= currentShortcuts.length) return;
    currentShortcuts[index].enabled = enabled;
    renderShortcuts();
    await saveShortcuts();
}

let editingIndex = -1;

function editShortcut(index) {
    if (index < 0 || index >= currentShortcuts.length) return;
    const s = currentShortcuts[index];
    document.getElementById('triggerInput').value = s.trigger;
    document.getElementById('replacementInput').value = s.replacement;
    document.getElementById('triggerInput').focus();
    editingIndex = index;
    
    const btn = document.querySelector('.shortcut-form button[type="submit"]');
    btn.textContent = 'Lưu';
}

function resetForm() {
    document.getElementById('triggerInput').value = '';
    document.getElementById('replacementInput').value = '';
    editingIndex = -1;
    const btn = document.querySelector('.shortcut-form button[type="submit"]');
    btn.textContent = 'Thêm';
}
