// FKey Frontend JavaScript
// Communicates with Go backend via Wails v3 runtime

// Current settings state
let currentSettings = {};
let currentShortcuts = [];
let formattingConfig = {};
let isLoading = true;

// Binding IDs (generated by wails3 generate bindings)
const BindingIDs = {
    GetSettings: 3726452464,
    SaveSettings: 1235119979,
    Toggle: 4113297479,
    SetInputMethod: 526728894,
    GetVersion: 3451983167,
    GetEnabled: 4139715286,
    SetEnabled: 1538332202,
    GetShortcuts: 96855928,
    SaveShortcuts: 2491486897,
    CheckForUpdates: 152619814,
    DownloadAndInstallUpdate: 29466370,
    GetFormattingConfig: 2794236240,
    SaveFormattingConfig: 4109063599,
    DetectCurrentApp: 3058819472,
};

// Wait for Wails runtime to be ready
function waitForWails() {
    return new Promise((resolve) => {
        // Check if wails global is available (from runtime.js)
        const check = () => {
            if (typeof wails !== 'undefined' && wails.Call && wails.Call.ByID) {
                resolve();
                return true;
            }
            return false;
        };
        
        if (check()) return;
        
        // Poll for runtime
        const checkInterval = setInterval(() => {
            if (check()) {
                clearInterval(checkInterval);
            }
        }, 50);
        
        // Timeout after 5 seconds
        setTimeout(() => {
            clearInterval(checkInterval);
            resolve(); // Continue anyway, will show error
        }, 5000);
    });
}

// Wails v3 Call wrapper using ByID
const App = {
    GetSettings: async () => {
        try {
            return await wails.Call.ByID(BindingIDs.GetSettings);
        } catch (e) {
            console.error('GetSettings error:', e);
            throw e;
        }
    },
    SaveSettings: async (settings) => {
        return await wails.Call.ByID(BindingIDs.SaveSettings, settings);
    },
    Toggle: async () => {
        return await wails.Call.ByID(BindingIDs.Toggle);
    },
    SetInputMethod: async (method) => {
        return await wails.Call.ByID(BindingIDs.SetInputMethod, method);
    },
    GetVersion: async () => {
        return await wails.Call.ByID(BindingIDs.GetVersion);
    },
    GetShortcuts: async () => {
        try {
            return await wails.Call.ByID(BindingIDs.GetShortcuts);
        } catch (e) {
            console.error('GetShortcuts error:', e);
            return [];
        }
    },
    SaveShortcuts: async (shortcuts) => {
        return await wails.Call.ByID(BindingIDs.SaveShortcuts, shortcuts);
    },
    CheckForUpdates: async (force) => {
        try {
            return await wails.Call.ByID(BindingIDs.CheckForUpdates, force);
        } catch (e) {
            console.error('CheckForUpdates error:', e);
            return null;
        }
    },
    DownloadAndInstallUpdate: async (downloadURL) => {
        return await wails.Call.ByID(BindingIDs.DownloadAndInstallUpdate, downloadURL);
    },
    GetFormattingConfig: async () => {
        try {
            return await wails.Call.ByID(BindingIDs.GetFormattingConfig);
        } catch (e) {
            console.error('GetFormattingConfig error:', e);
            return { enabled: false, defaultProfile: 'disabled', hotkeys: {}, apps: {} };
        }
    },
    SaveFormattingConfig: async (config) => {
        return await wails.Call.ByID(BindingIDs.SaveFormattingConfig, config);
    },
    DetectCurrentApp: async () => {
        return await wails.Call.ByID(BindingIDs.DetectCurrentApp);
    },
};

document.addEventListener('DOMContentLoaded', async () => {
    console.log('FKey Settings UI initializing...');
    
    // Wait for Wails runtime
    await waitForWails();
    
    if (typeof wails === 'undefined' || !wails.Call) {
        showError('Không thể kết nối với ứng dụng. Vui lòng khởi động lại.');
        return;
    }
    
    console.log('Wails runtime ready');
    
    try {
        // Load settings from backend
        currentSettings = await App.GetSettings();
        console.log('Settings loaded:', currentSettings);
        applySettingsToUI(currentSettings);
        
        // Load version
        const version = await App.GetVersion();
        document.getElementById('versionText').textContent = `FKey v${version}`;
        
        // Load shortcuts
        await loadShortcuts();
        
        // Load formatting config
        await loadFormattingConfig();
        
        isLoading = false;
        document.body.classList.remove('loading');
    } catch (err) {
        console.error('Failed to load settings:', err);
        showError('Không thể tải cài đặt: ' + err.message);
    }
    
    // Set up event listeners
    setupEventListeners();
    setupFormattingEventListeners();
    
    // Check for updates (async, non-blocking)
    checkForUpdates();
});

async function checkForUpdates() {
    try {
        const updateInfo = await App.CheckForUpdates(false);
        if (updateInfo && updateInfo.available && updateInfo.downloadURL) {
            showUpdateDialog(updateInfo);
        }
    } catch (e) {
        console.log('Update check failed:', e);
    }
}

function showUpdateDialog(updateInfo) {
    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.className = 'update-overlay';
    overlay.innerHTML = `
        <div class="update-dialog">
            <h3>Cập nhật mới</h3>
            <p>Phiên bản <strong>${updateInfo.latestVersion}</strong> đã sẵn sàng!</p>
            <p class="update-notes">${updateInfo.releaseNotes || ''}</p>
            <div class="update-buttons">
                <button class="update-btn-yes">Cập nhật ngay</button>
                <button class="update-btn-no">Để sau</button>
            </div>
            <p class="update-status" style="display:none;"></p>
        </div>
    `;
    document.body.appendChild(overlay);
    
    overlay.querySelector('.update-btn-yes').addEventListener('click', async () => {
        const status = overlay.querySelector('.update-status');
        const buttons = overlay.querySelector('.update-buttons');
        buttons.style.display = 'none';
        status.style.display = 'block';
        status.textContent = 'Đang tải xuống...';
        
        try {
            await App.DownloadAndInstallUpdate(updateInfo.downloadURL);
            status.textContent = 'Đang cài đặt, ứng dụng sẽ khởi động lại...';
            // App will be closed by the backend, batch script will restart
            setTimeout(() => {
                if (wails.Window && wails.Window.Close) {
                    wails.Window.Close();
                } else if (wails.Application && wails.Application.Quit) {
                    wails.Application.Quit();
                }
            }, 1000);
        } catch (e) {
            status.textContent = 'Lỗi: ' + e.message;
            buttons.style.display = 'flex';
        }
    });
    
    overlay.querySelector('.update-btn-no').addEventListener('click', () => {
        overlay.remove();
    });
}

function showError(msg) {
    const container = document.querySelector('.container');
    const existing = container.querySelector('.error-msg');
    if (existing) existing.remove();
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-msg';
    errorDiv.textContent = msg;
    container.insertBefore(errorDiv, container.firstChild.nextSibling);
}

function applySettingsToUI(settings) {
    // Status indicator
    updateStatusIndicator(settings.enabled);
    
    // Input method
    const methodRadios = document.querySelectorAll('input[name="inputMethod"]');
    methodRadios.forEach(radio => {
        radio.checked = parseInt(radio.value) === settings.inputMethod;
    });
    
    // Tone style
    // NOTE: Rust engine uses inverted terminology:
    // - modern_tone=true  → hoà, thuý (dấu ở nguyên âm sau - actually old style in VietNet)  
    // - modern_tone=false → hòa, thúy (dấu ở nguyên âm đầu - actually new style in VietNet)
    // UI shows: "Mới (hòa)" and "Cũ (hoà)", so we invert the mapping
    const toneRadios = document.querySelectorAll('input[name="toneStyle"]');
    toneRadios.forEach(radio => {
        radio.checked = (radio.value === 'modern') !== settings.modernTone;
    });
    
    // Hotkey display
    updateHotkeyDisplay(settings.toggleHotkey);
    
    // Advanced settings
    const checkboxes = {
        'skipW': settings.skipWShortcut,
        'escRestore': settings.escRestore !== false,
        'freeTone': settings.freeTone,
        'englishRestore': settings.englishAutoRestore,
        'autoCapitalize': settings.autoCapitalize !== false,
        'autoStart': settings.autoStart
    };
    
    for (const [id, value] of Object.entries(checkboxes)) {
        const el = document.getElementById(id);
        if (el) el.checked = value || false;
    }
}

function updateStatusIndicator(enabled) {
    const indicator = document.getElementById('statusIndicator');
    const dot = indicator.querySelector('.status-dot');
    const text = indicator.querySelector('.status-text');
    
    if (enabled) {
        dot.classList.remove('disabled');
        text.textContent = 'Tiếng Việt: Đang bật';
    } else {
        dot.classList.add('disabled');
        text.textContent = 'Tiếng Việt: Đang tắt';
    }
}

function updateHotkeyDisplay(hotkeyStr) {
    const btn = document.getElementById('hotkeyBtn');
    if (!hotkeyStr) {
        btn.textContent = 'Ctrl+Space';
        return;
    }
    
    const parts = hotkeyStr.split(',');
    if (parts.length < 2) {
        btn.textContent = 'Ctrl+Space';
        return;
    }
    
    const keyCode = parseInt(parts[0]);
    const modifiers = parseInt(parts[1]);
    
    let display = [];
    if (modifiers & 1) display.push('Ctrl');
    if (modifiers & 2) display.push('Alt');
    if (modifiers & 4) display.push('Shift');
    
    display.push(getKeyName(keyCode));
    btn.textContent = display.join('+');
}

function getKeyName(keyCode) {
    const keyMap = {
        0x20: 'Space', 0x08: 'Backspace', 0x09: 'Tab',
        0x0D: 'Enter', 0x1B: 'Escape',
        0x70: 'F1', 0x71: 'F2', 0x72: 'F3', 0x73: 'F4',
        0x74: 'F5', 0x75: 'F6', 0x76: 'F7', 0x77: 'F8',
        0x78: 'F9', 0x79: 'F10', 0x7A: 'F11', 0x7B: 'F12',
    };
    
    if (keyMap[keyCode]) return keyMap[keyCode];
    if (keyCode >= 0x41 && keyCode <= 0x5A) return String.fromCharCode(keyCode);
    if (keyCode >= 0x30 && keyCode <= 0x39) return String.fromCharCode(keyCode);
    
    return `Key${keyCode}`;
}

function setupEventListeners() {
    // Status toggle (click on status section)
    document.querySelector('.status-section').addEventListener('click', async () => {
        if (isLoading) return;
        try {
            const newState = await App.Toggle();
            currentSettings.enabled = newState;
            updateStatusIndicator(newState);
        } catch (err) {
            console.error('Failed to toggle:', err);
        }
    });
    
    // Shortcut form submit
    const shortcutForm = document.getElementById('shortcutForm');
    if (shortcutForm) {
        shortcutForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const triggerInput = document.getElementById('triggerInput');
            const replacementInput = document.getElementById('replacementInput');
            const trigger = triggerInput.value.trim();
            const replacement = replacementInput.value.trim();
            
            if (trigger && replacement) {
                await addShortcut(trigger, replacement);
                triggerInput.value = '';
                replacementInput.value = '';
                triggerInput.focus();
            }
        });
    }
    
    // Input method change
    document.querySelectorAll('input[name="inputMethod"]').forEach(radio => {
        radio.addEventListener('change', async (e) => {
            if (isLoading) return;
            const method = parseInt(e.target.value);
            try {
                await App.SetInputMethod(method);
                currentSettings.inputMethod = method;
                console.log('Input method:', method === 0 ? 'Telex' : 'VNI');
            } catch (err) {
                console.error('Failed to set input method:', err);
            }
        });
    });
    
    // Tone style change
    // NOTE: Invert the value because Rust engine uses inverted terminology
    document.querySelectorAll('input[name="toneStyle"]').forEach(radio => {
        radio.addEventListener('change', async (e) => {
            if (isLoading) return;
            currentSettings.modernTone = e.target.value !== 'modern';
            await saveSettings();
        });
    });
    
    // Advanced settings checkboxes
    const checkboxMapping = {
        'skipW': 'skipWShortcut',
        'escRestore': 'escRestore',
        'freeTone': 'freeTone',
        'englishRestore': 'englishAutoRestore',
        'autoCapitalize': 'autoCapitalize',
        'autoStart': 'autoStart',
    };
    
    Object.entries(checkboxMapping).forEach(([elemId, settingKey]) => {
        const el = document.getElementById(elemId);
        if (el) {
            el.addEventListener('change', async (e) => {
                if (isLoading) return;
                currentSettings[settingKey] = e.target.checked;
                await saveSettings();
            });
        }
    });
    
    // Hotkey button - recording mode
    const hotkeyBtn = document.getElementById('hotkeyBtn');
    let isRecording = false;
    
    hotkeyBtn.addEventListener('click', () => {
        if (isRecording) return;
        isRecording = true;
        hotkeyBtn.textContent = 'Nhấn phím...';
        hotkeyBtn.classList.add('recording');
        console.log('Hotkey recording started');
        
        const handler = async (e) => {
            console.log('Key pressed:', e.key, 'keyCode:', e.keyCode, 'modifiers:', e.ctrlKey, e.altKey, e.shiftKey);
            e.preventDefault();
            e.stopPropagation();
            
            // Ignore modifier-only presses
            if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
                return;
            }
            
            const keyCode = e.keyCode;
            let modifiers = 0;
            if (e.ctrlKey) modifiers |= 1;
            if (e.altKey) modifiers |= 2;
            if (e.shiftKey) modifiers |= 4;
            
            // Require at least one modifier
            if (modifiers === 0) {
                hotkeyBtn.textContent = 'Cần Ctrl/Alt/Shift';
                setTimeout(() => {
                    updateHotkeyDisplay(currentSettings.toggleHotkey);
                    hotkeyBtn.classList.remove('recording');
                    isRecording = false;
                }, 1200);
                document.removeEventListener('keydown', handler);
                return;
            }
            
            currentSettings.toggleHotkey = `${keyCode},${modifiers}`;
            console.log('New hotkey set:', currentSettings.toggleHotkey);
            updateHotkeyDisplay(currentSettings.toggleHotkey);
            hotkeyBtn.classList.remove('recording');
            isRecording = false;
            document.removeEventListener('keydown', handler);
            
            await saveSettings();
        };
        
        document.addEventListener('keydown', handler);
    });
    
    // Feedback link
    document.getElementById('feedbackLink')?.addEventListener('click', (e) => {
        e.preventDefault();
        if (wails.Browser && wails.Browser.OpenURL) {
            wails.Browser.OpenURL('https://github.com/miken90/fkey/issues');
        } else {
            window.open('https://github.com/miken90/fkey/issues', '_blank');
        }
    });
}

async function saveSettings() {
    try {
        await App.SaveSettings(currentSettings);
        console.log('Settings saved');
    } catch (err) {
        console.error('Failed to save settings:', err);
    }
}

// Shortcuts CRUD
async function loadShortcuts() {
    try {
        currentShortcuts = await App.GetShortcuts() || [];
        renderShortcuts();
        console.log('Shortcuts loaded:', currentShortcuts.length);
    } catch (err) {
        console.error('Failed to load shortcuts:', err);
        currentShortcuts = [];
        renderShortcuts();
    }
}

async function saveShortcuts() {
    try {
        await App.SaveShortcuts(currentShortcuts);
        console.log('Shortcuts saved');
    } catch (err) {
        console.error('Failed to save shortcuts:', err);
    }
}

function renderShortcuts() {
    const list = document.getElementById('shortcutList');
    if (!list) return;
    
    if (currentShortcuts.length === 0) {
        list.innerHTML = '<div class="shortcut-empty">Chưa có viết tắt nào</div>';
        return;
    }
    
    list.innerHTML = currentShortcuts.map((s, i) => {
        const enabled = s.enabled !== false;
        return `
        <div class="shortcut-item${enabled ? '' : ' disabled'}" data-index="${i}">
            <input type="checkbox" class="toggle-btn" ${enabled ? 'checked' : ''} title="Bật/tắt">
            <span class="trigger">${escapeHtml(s.trigger)}</span>
            <span class="arrow">→</span>
            <span class="replacement">${escapeHtml(s.replacement)}</span>
            <button class="edit-btn" title="Sửa">✎</button>
            <button class="delete-btn" title="Xóa">×</button>
        </div>
    `}).join('');
    
    list.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('change', (e) => {
            const index = parseInt(e.target.closest('.shortcut-item').dataset.index);
            toggleShortcut(index, e.target.checked);
        });
    });
    
    list.querySelectorAll('.edit-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.closest('.shortcut-item').dataset.index);
            editShortcut(index);
        });
    });
    
    list.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.closest('.shortcut-item').dataset.index);
            deleteShortcut(index);
        });
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function addShortcut(trigger, replacement) {
    if (!trigger || !replacement) return;
    
    if (editingIndex >= 0) {
        currentShortcuts[editingIndex].trigger = trigger;
        currentShortcuts[editingIndex].replacement = replacement;
    } else {
        const existing = currentShortcuts.findIndex(s => s.trigger === trigger);
        if (existing >= 0) {
            currentShortcuts[existing].replacement = replacement;
        } else {
            currentShortcuts.push({ trigger, replacement, enabled: true });
        }
    }
    
    renderShortcuts();
    resetForm();
    await saveShortcuts();
}

async function deleteShortcut(index) {
    if (index < 0 || index >= currentShortcuts.length) return;
    currentShortcuts.splice(index, 1);
    renderShortcuts();
    await saveShortcuts();
}

async function toggleShortcut(index, enabled) {
    if (index < 0 || index >= currentShortcuts.length) return;
    currentShortcuts[index].enabled = enabled;
    renderShortcuts();
    await saveShortcuts();
}

let editingIndex = -1;

function editShortcut(index) {
    if (index < 0 || index >= currentShortcuts.length) return;
    const s = currentShortcuts[index];
    document.getElementById('triggerInput').value = s.trigger;
    document.getElementById('replacementInput').value = s.replacement;
    document.getElementById('triggerInput').focus();
    editingIndex = index;
    
    const btn = document.querySelector('.shortcut-form button[type="submit"]');
    btn.textContent = 'Lưu';
}

function resetForm() {
    document.getElementById('triggerInput').value = '';
    document.getElementById('replacementInput').value = '';
    editingIndex = -1;
    const btn = document.querySelector('.shortcut-form button[type="submit"]');
    btn.textContent = 'Thêm';
}

// =====================================================
// Formatting Feature
// =====================================================

const DEFAULT_HOTKEYS = {
    bold: 'Ctrl+B',
    italic: 'Ctrl+I',
    underline: 'Ctrl+U',
    code: 'Ctrl+`',
    strikethrough: 'Ctrl+Alt+S',
    link: 'Ctrl+K'
};

const HOTKEY_LABELS = {
    bold: 'In đậm',
    italic: 'In nghiêng',
    underline: 'Gạch chân',
    code: 'Code',
    strikethrough: 'Gạch ngang',
    link: 'Liên kết'
};

async function loadFormattingConfig() {
    try {
        formattingConfig = await App.GetFormattingConfig() || {};
        if (!formattingConfig.hotkeys) formattingConfig.hotkeys = {};
        if (!formattingConfig.apps) formattingConfig.apps = {};
        if (formattingConfig.defaultProfile === undefined) formattingConfig.defaultProfile = 'disabled';
        if (formattingConfig.enabled === undefined) formattingConfig.enabled = false;
        
        applyFormattingToUI();
        console.log('Formatting config loaded:', formattingConfig);
    } catch (err) {
        console.error('Failed to load formatting config:', err);
        formattingConfig = { enabled: false, defaultProfile: 'disabled', hotkeys: {}, apps: {} };
        applyFormattingToUI();
    }
}

function applyFormattingToUI() {
    const enabledCheckbox = document.getElementById('formattingEnabled');
    if (enabledCheckbox) {
        enabledCheckbox.checked = formattingConfig.enabled || false;
    }
    
    const defaultProfile = document.getElementById('defaultFormattingProfile');
    if (defaultProfile) {
        defaultProfile.value = formattingConfig.defaultProfile || 'disabled';
    }
    
    renderFormattingHotkeys();
    renderFormattingApps();
}

function renderFormattingHotkeys() {
    const list = document.getElementById('formattingHotkeyList');
    if (!list) return;
    
    const hotkeys = { ...DEFAULT_HOTKEYS, ...formattingConfig.hotkeys };
    
    list.innerHTML = Object.entries(DEFAULT_HOTKEYS).map(([type, defaultKey]) => {
        const currentKey = hotkeys[type] || defaultKey;
        const isCustom = formattingConfig.hotkeys && formattingConfig.hotkeys[type];
        return `
        <div class="hotkey-row" data-type="${type}">
            <span class="hotkey-name">${HOTKEY_LABELS[type] || type}</span>
            <button class="hotkey-key ${isCustom ? 'custom' : ''}" data-type="${type}">${escapeHtml(currentKey)}</button>
            ${isCustom ? `<button class="hotkey-reset" data-type="${type}" title="Đặt lại">↺</button>` : ''}
        </div>
    `}).join('');
    
    // Click to edit hotkey
    list.querySelectorAll('.hotkey-key').forEach(btn => {
        btn.addEventListener('click', (e) => {
            startHotkeyCapture(e.target);
        });
    });
    
    // Reset button
    list.querySelectorAll('.hotkey-reset').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            const type = e.target.dataset.type;
            delete formattingConfig.hotkeys[type];
            await saveFormattingConfig();
            renderFormattingHotkeys();
        });
    });
}

// Hotkey capture state
let capturingHotkeyBtn = null;

function startHotkeyCapture(btn) {
    if (capturingHotkeyBtn) {
        capturingHotkeyBtn.classList.remove('capturing');
        capturingHotkeyBtn.textContent = capturingHotkeyBtn.dataset.originalText;
    }
    
    btn.dataset.originalText = btn.textContent;
    btn.textContent = 'Nhấn phím...';
    btn.classList.add('capturing');
    capturingHotkeyBtn = btn;
    
    document.addEventListener('keydown', captureHotkey);
}

function captureHotkey(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Ignore modifier-only keys
    if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
        return;
    }
    
    // Build hotkey string
    const parts = [];
    if (e.ctrlKey) parts.push('Ctrl');
    if (e.altKey) parts.push('Alt');
    if (e.shiftKey) parts.push('Shift');
    
    // Get key name
    let keyName = e.key;
    if (keyName === ' ') keyName = 'Space';
    else if (keyName === '`') keyName = '`';
    else if (keyName.length === 1) keyName = keyName.toUpperCase();
    else if (keyName.startsWith('Arrow')) keyName = keyName.replace('Arrow', '');
    
    parts.push(keyName);
    const hotkeyStr = parts.join('+');
    
    // Validate: must have at least Ctrl or Alt
    if (!e.ctrlKey && !e.altKey) {
        capturingHotkeyBtn.textContent = capturingHotkeyBtn.dataset.originalText;
        capturingHotkeyBtn.classList.remove('capturing');
        capturingHotkeyBtn = null;
        document.removeEventListener('keydown', captureHotkey);
        return;
    }
    
    // Save
    const type = capturingHotkeyBtn.dataset.type;
    formattingConfig.hotkeys = formattingConfig.hotkeys || {};
    
    // If same as default, remove custom
    if (hotkeyStr === DEFAULT_HOTKEYS[type]) {
        delete formattingConfig.hotkeys[type];
    } else {
        formattingConfig.hotkeys[type] = hotkeyStr;
    }
    
    capturingHotkeyBtn.classList.remove('capturing');
    capturingHotkeyBtn = null;
    document.removeEventListener('keydown', captureHotkey);
    
    saveFormattingConfig().then(() => {
        renderFormattingHotkeys();
    });
}

function renderFormattingApps() {
    const list = document.getElementById('formattingAppList');
    if (!list) return;
    
    const apps = formattingConfig.apps || {};
    const appEntries = Object.entries(apps);
    
    if (appEntries.length === 0) {
        list.innerHTML = '<div class="shortcut-empty">Chưa có ứng dụng nào</div>';
        return;
    }
    
    list.innerHTML = appEntries.map(([name, config]) => {
        const profile = typeof config === 'string' ? config : (config.profile || 'markdown');
        const excludeHotkeys = (config && config.excludeHotkeys) || [];
        
        // Build hotkey exclusion checkboxes
        const hotkeyTypes = ['bold', 'italic', 'underline', 'code', 'strikethrough', 'link'];
        const excludeCheckboxes = hotkeyTypes.map(type => {
            const isExcluded = excludeHotkeys.includes(type);
            const label = HOTKEY_LABELS[type] || type;
            const hotkey = DEFAULT_HOTKEYS[type] || '';
            return `
                <label class="exclude-checkbox" title="${hotkey}">
                    <input type="checkbox" data-type="${type}" ${isExcluded ? 'checked' : ''}>
                    <span>${label}</span>
                </label>
            `;
        }).join('');
        
        return `
            <div class="app-row-expandable" data-app="${escapeHtml(name)}">
                <div class="app-row-header">
                    <span class="app-expand-icon">▶</span>
                    <span class="app-name">${escapeHtml(name)}</span>
                    <select class="app-profile-select">
                        <option value="markdown" ${profile === 'markdown' ? 'selected' : ''}>MD</option>
                        <option value="html" ${profile === 'html' ? 'selected' : ''}>HTML</option>
                    </select>
                    <button class="remove-btn" title="Xóa">×</button>
                </div>
                <div class="app-row-details">
                    <div class="exclude-section">
                        <span class="exclude-label">Bỏ qua (dùng phím tắt gốc):</span>
                        <div class="exclude-checkboxes">${excludeCheckboxes}</div>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // Toggle expand/collapse
    list.querySelectorAll('.app-row-header').forEach(header => {
        header.addEventListener('click', (e) => {
            // Don't toggle if clicking on select or button
            if (e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'OPTION') {
                return;
            }
            const row = e.target.closest('.app-row-expandable');
            row.classList.toggle('expanded');
        });
    });
    
    // Profile select
    list.querySelectorAll('.app-profile-select').forEach(select => {
        select.addEventListener('change', async (e) => {
            e.stopPropagation();
            const appName = e.target.closest('.app-row-expandable').dataset.app;
            await updateAppProfile(appName, e.target.value);
        });
    });
    
    // Remove button
    list.querySelectorAll('.remove-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const appName = e.target.closest('.app-row-expandable').dataset.app;
            removeFormattingApp(appName);
        });
    });
    
    // Exclude checkboxes
    list.querySelectorAll('.exclude-checkbox input').forEach(checkbox => {
        checkbox.addEventListener('change', async (e) => {
            const appName = e.target.closest('.app-row-expandable').dataset.app;
            const hotkeyType = e.target.dataset.type;
            const isExcluded = e.target.checked;
            await updateAppExclusion(appName, hotkeyType, isExcluded);
        });
    });
}

async function updateAppExclusion(appName, hotkeyType, isExcluded) {
    if (!formattingConfig.apps || !formattingConfig.apps[appName]) return;
    
    let config = formattingConfig.apps[appName];
    if (typeof config === 'string') {
        config = { profile: config, excludeHotkeys: [] };
        formattingConfig.apps[appName] = config;
    }
    
    if (!config.excludeHotkeys) {
        config.excludeHotkeys = [];
    }
    
    if (isExcluded) {
        if (!config.excludeHotkeys.includes(hotkeyType)) {
            config.excludeHotkeys.push(hotkeyType);
        }
    } else {
        config.excludeHotkeys = config.excludeHotkeys.filter(h => h !== hotkeyType);
    }
    
    await saveFormattingConfig();
}

async function updateAppProfile(appName, profile) {
    if (!formattingConfig.apps || !formattingConfig.apps[appName]) return;
    
    let config = formattingConfig.apps[appName];
    if (typeof config === 'string') {
        config = { profile: config };
        formattingConfig.apps[appName] = config;
    }
    config.profile = profile;
    await saveFormattingConfig();
}

async function saveFormattingConfig() {
    try {
        await App.SaveFormattingConfig(formattingConfig);
        console.log('Formatting config saved');
    } catch (err) {
        console.error('Failed to save formatting config:', err);
    }
}

async function addFormattingApp(name, profile) {
    if (!name || !profile) return;
    
    const cleanName = name.trim().toLowerCase();
    if (!cleanName) return;
    
    formattingConfig.apps = formattingConfig.apps || {};
    formattingConfig.apps[cleanName] = { profile: profile };
    
    renderFormattingApps();
    await saveFormattingConfig();
}

async function removeFormattingApp(name) {
    if (!formattingConfig.apps) return;
    
    delete formattingConfig.apps[name];
    renderFormattingApps();
    await saveFormattingConfig();
}

function setupFormattingEventListeners() {
    const enabledCheckbox = document.getElementById('formattingEnabled');
    if (enabledCheckbox) {
        enabledCheckbox.addEventListener('change', async (e) => {
            if (isLoading) return;
            formattingConfig.enabled = e.target.checked;
            await saveFormattingConfig();
        });
    }
    
    const defaultProfile = document.getElementById('defaultFormattingProfile');
    if (defaultProfile) {
        defaultProfile.addEventListener('change', async (e) => {
            if (isLoading) return;
            formattingConfig.defaultProfile = e.target.value;
            await saveFormattingConfig();
        });
    }
    
    const addAppBtn = document.getElementById('addAppBtn');
    const newAppName = document.getElementById('newAppName');
    const newAppProfile = document.getElementById('newAppProfile');
    const detectAppBtn = document.getElementById('detectAppBtn');
    
    // Detect button - countdown then capture active app
    if (detectAppBtn && newAppName) {
        detectAppBtn.addEventListener('click', async () => {
            const originalText = detectAppBtn.textContent;
            detectAppBtn.disabled = true;
            
            // Countdown 3 seconds
            for (let i = 3; i > 0; i--) {
                detectAppBtn.textContent = i.toString();
                await new Promise(r => setTimeout(r, 1000));
            }
            
            // Detect current app
            try {
                const appName = await App.DetectCurrentApp();
                if (appName) {
                    newAppName.value = appName;
                }
            } catch (e) {
                console.error('DetectCurrentApp error:', e);
            }
            
            detectAppBtn.textContent = originalText;
            detectAppBtn.disabled = false;
        });
    }
    
    if (addAppBtn && newAppName && newAppProfile) {
        addAppBtn.addEventListener('click', async () => {
            const name = newAppName.value.trim();
            const profile = newAppProfile.value;
            if (name) {
                await addFormattingApp(name, profile);
                newAppName.value = '';
            }
        });
    }
}
